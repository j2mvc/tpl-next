{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime-corejs2/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime-corejs2/helpers/esm/asyncToGenerator\";\nimport axios from 'axios';\nimport http from 'http';\nvar apiPrefix = 'http://api.ptjp.gov.cn';\nvar apiKey = '66bb75d01825f4e06963dd645d901bbe'; // 创建一个 axios 实例\n\nvar service = axios.create({\n  // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。\n  // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL\n  baseURL: apiPrefix,\n  // `timeout` 指定请求超时的毫秒数(0 表示无超时时间)\n  // 如果请求话费了超过 `timeout` 的时间，请求将被中断\n  timeout: 5000,\n  // `withCredentials` 表示跨域请求时是否需要使用凭证\n  // withCredentials: false, // 默认值为false\n  // `url` 是用于请求的服务器 URL\n  // `paramsSerializer` 是一个负责 `params` 序列化的函数\n  // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)\n  // paramsSerializer: function(params) {\n  //     return Qs.stringify(params, {arrayFormat: 'brackets'})\n  // },\n  // `adapter` 允许自定义处理请求，以使测试更轻松\n  // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)).\n  // adapter: function (config) {\n  //     /* ... */\n  // },\n  // `responseType` 表示服务器响应的数据类型，可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream'\n  // responseType: 'json', // 默认的\n  // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称\n  // xsrfCookieName: 'XSRF-TOKEN', // default\n  // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称\n  // xsrfHeaderName: 'X-XSRF-TOKEN', // 默认的\n  // `onUploadProgress` 允许为上传处理进度事件\n  // onUploadProgress: function (progressEvent) {\n  //     // 对原生进度事件的处理\n  // },\n  // `onDownloadProgress` 允许为下载处理进度事件\n  // onDownloadProgress: function (progressEvent) {\n  //     // 对原生进度事件的处理\n  // },\n  // `maxContentLength` 定义允许的响应内容的最大尺寸\n  // maxContentLength: 2000,\n  // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte\n  // validateStatus: function (status) {\n  //     return status >= 200 && status < 300; // 默认的\n  // },\n  // headers: {\n  //     referer: 'https://ptjp.gov.cn/',\n  //     host: 'ptjp.gov.cn'\n  // },\n  // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目\n  // 如果设置为0，将不会 follow 任何重定向\n  // maxRedirects: 5, // 默认的\n  // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：\n  // `keepAlive` 默认没有启用\n  httpAgent: new http.Agent({\n    keepAlive: true\n  }),\n  // httpsAgent: new https.Agent({ keepAlive: true }),\n  // 'proxy' 定义代理服务器的主机名称和端口\n  // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据\n  // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。\n  proxy: {\n    host: 'api.ptjp.gov.cn',\n    port: 80 // auth: {\n    //     username: 'mikeymike',\n    //     password: 'rapunz3l'\n    // },\n    // `cancelToken` 指定用于取消请求的 cancel token\n    // cancelToken: new CancelToken(function (cancel) {\n    // })\n\n  }\n});\n/**\n * 处理错误代码\n * @param error\n * @returns {{error: (*|{code: number, message: string})}}\n */\n\nvar handleError = function handleError(error) {\n  error = error || {\n    code: -1,\n    message: '请求失败'\n  }; // 对响应错误做点什么\n\n  if (error.response) {\n    switch (error.response.status) {\n      case 400:\n        error.message = '请求错误';\n        break;\n\n      case 401:\n        error.message = '未授权，请登录';\n        break;\n\n      case 403:\n        error.message = '拒绝访问';\n        break;\n\n      case 404:\n        error.message = \"\\u8BF7\\u6C42\\u5730\\u5740\\u51FA\\u9519: \".concat(error.response.config.url);\n        break;\n\n      case 408:\n        error.message = '请求超时';\n        break;\n\n      case 500:\n        error.message = '服务器内部错误';\n        break;\n\n      case 501:\n        error.message = '服务未实现';\n        break;\n\n      case 502:\n        error.message = '网关错误';\n        break;\n\n      case 503:\n        error.message = '服务不可用';\n        break;\n\n      case 504:\n        error.message = '网关超时';\n        break;\n\n      case 505:\n        error.message = 'HTTP版本不受支持';\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  return {\n    error: error\n  };\n};\n/**\n * 拼接url的querystring\n * @param params\n * @returns {string}\n */\n\n\nvar parseParams = function parseParams(params) {\n  var str = '';\n\n  for (var k in params) {\n    var v = params[k];\n    str += (str != '' ? '&' : '?') + k + '=' + v;\n  }\n\n  return str;\n};\n/**\n * get数据\n * @param url\n * @param params\n * @param cache\n * @returns {Promise<*>}\n */\n\n\nvar get =\n/*#__PURE__*/\nfunction () {\n  var _ref = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee(props) {\n    var url, params, cache;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            url = props.url, params = props.params, cache = props.cache; // 这会在应用中暴露\n\n            params.apikey = apiKey;\n            return _context.abrupt(\"return\", service({\n              method: 'get',\n              url: url,\n              params: params,\n              mode: 'no-cors'\n            }).then(function (res) {\n              if (res.error) {\n                return {\n                  error: res.error\n                };\n              }\n\n              var json = res.data; // 获取到数据\n\n              if (json.code == 1) {\n                return json;\n              } // 处理服务器返回的错误\n\n\n              if (json.error) {\n                return handleError(json.error);\n              } else {\n                var message = json.message ? json.message : '请求失败';\n                return handleError({\n                  code: -1,\n                  message: message\n                });\n              }\n            }).catch(function (error) {\n              return handleError(error);\n            }));\n\n          case 3:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function get(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * 提交数据\n * @param url\n * @param data\n * @param cache\n * @returns {*}\n */\n\n\nvar post = function post(_ref2) {\n  var url = _ref2.url,\n      data = _ref2.data,\n      cache = _ref2.cache;\n};\n\nexport default {\n  get: get,\n  post: post\n};","map":null,"metadata":{},"sourceType":"module"}